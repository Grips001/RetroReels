<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro 3-Reel Slot Machine</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #00ff00;
            font-family: "Courier New", monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        #game-container {
            text-align: center;
            background: #2a2a2a;
            padding: 20px;
            border: 2px solid #00ff00;
            border-radius: 8px;
        }
        
        canvas {
            border: 1px solid #00ff00;
            background: #000;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }
        
        button {
            background: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 10px 20px;
            font-family: inherit;
            cursor: pointer;
            border-radius: 4px;
        }
        
        button:hover {
            background: #004400;
        }
        
        button:focus {
            outline: 2px solid #00ff00;
            outline-offset: 2px;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #spin-btn {
            min-width: 120px;
        }
        
        .status {
            margin-top: 15px;
            font-size: 14px;
        }
        
        .win-message {
            margin-top: 10px;
            color: #ffff00;
            font-weight: bold;
            min-height: 20px;
        }
        
        .paytable {
            margin-top: 20px;
            font-size: 12px;
            text-align: left;
            max-width: 300px;
        }
        
        .paytable h3 {
            color: #ffff00;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>RETRO SLOT</h1>
        <canvas id="game-canvas" width="300" height="300"></canvas>
        
        <div class="controls">
            <button id="bet-down" aria-label="Decrease bet">BET -</button>
            <button id="spin-btn" aria-label="Spin reels">SPIN</button>
            <button id="bet-up" aria-label="Increase bet">BET +</button>
            <button id="mute-btn" aria-label="Toggle sound">SOUND</button>
        </div>
        
        <div class="status">
            <div>Credits: <span id="credits">100</span></div>
            <div>Bet: <span id="bet">1</span></div>
            <div>Last Win: <span id="last-win">0</span></div>
        </div>
        
        <div class="win-message" id="win-message" aria-live="polite"></div>
        
        <div class="paytable">
            <h3>PAYTABLE</h3>
            <div>3√ó SEVEN: 50 credits</div>
            <div>3√ó BELL: 40 credits</div>
            <div>3√ó STAR: 30 credits</div>
            <div>3√ó DIAMOND: 20 credits</div>
            <div>3√ó CHERRY: 10 credits</div>
            <div>3√ó LEMON: 5 credits</div>
        </div>
    </div>

    <script>
        class RetroSlotMachine {
            constructor() {
                // Symbols with payouts (based on working simple-slot.html structure)
                this.symbols = [
                    { char: 'üçí', name: 'CHERRY', payout: 10, color: '#ff4444' },
                    { char: 'üçã', name: 'LEMON', payout: 5, color: '#ffff44' },
                    { char: 'üíé', name: 'DIAMOND', payout: 20, color: '#00ccff' },
                    { char: 'üîî', name: 'BELL', payout: 40, color: '#ffaa00' },
                    { char: '‚òÖ', name: 'STAR', payout: 30, color: '#4444ff' },
                    { char: '7', name: 'SEVEN', payout: 50, color: '#44ff44' }
                ];
                
                // 9 paylines for 3x3 grid
                this.paylines = [
                    { name: 'Top Row', indices: [0, 1, 2] },
                    { name: 'Middle Row', indices: [3, 4, 5] },
                    { name: 'Bottom Row', indices: [6, 7, 8] },
                    { name: 'Main Diagonal', indices: [0, 4, 8] },
                    { name: 'Anti Diagonal', indices: [2, 4, 6] },
                    { name: 'Left Column', indices: [0, 3, 6] },
                    { name: 'Middle Column', indices: [1, 4, 7] },
                    { name: 'Right Column', indices: [2, 5, 8] },
                    { name: 'V-Shape', indices: [0, 4, 2] }
                ];
                
                // Create 3 physical reels with fixed symbol sequences (EXACTLY like simple-slot.html)
                this.reels = [
                    this.createReel(), // Left reel
                    this.createReel(), // Middle reel  
                    this.createReel()  // Right reel
                ];
                
                // Reel positions (how far down each reel has scrolled)
                this.reelPositions = [0, 0, 0];
                this.reelSpeeds = [0, 0, 0];
                this.reelSpinning = [false, false, false];
                
                // Game state
                this.credits = 100;
                this.bet = 1;
                this.lastWin = 0;
                this.spinning = false;
                this.isMuted = false;
                this.winningLines = [];
                
                // Canvas
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Audio
                this.audioContext = null;
                this.initAudio();
                
                this.init();
            }
            
            createReel() {
                // Create a reel with 20 symbols in a fixed sequence (EXACTLY like simple-slot.html)
                const reel = [];
                for (let i = 0; i < 20; i++) {
                    reel.push(this.symbols[Math.floor(Math.random() * this.symbols.length)]);
                }
                return reel;
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                }
            }
            
            enableAudio() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume().catch(e => console.warn('Audio resume failed:', e));
                }
            }
            
            init() {
                console.log('Initializing retro slot machine...');
                console.log('Reels created:', this.reels.map(reel => reel.slice(0, 5).map(s => s.char))); // Show first 5 symbols of each reel
                
                // Generate initial grid
                this.generateGrid();
                
                // Setup buttons
                document.getElementById('spin-btn').addEventListener('click', () => {
                    console.log('Spin button clicked');
                    this.enableAudio();
                    this.spin();
                });
                
                document.getElementById('bet-down').addEventListener('click', () => {
                    this.enableAudio();
                    this.changeBet(-1);
                });
                
                document.getElementById('bet-up').addEventListener('click', () => {
                    this.enableAudio();
                    this.changeBet(1);
                });
                
                document.getElementById('mute-btn').addEventListener('click', () => this.toggleMute());
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.enableAudio();
                        this.spin();
                    } else if (e.code === 'ArrowLeft') {
                        e.preventDefault();
                        this.changeBet(-1);
                    } else if (e.code === 'ArrowRight') {
                        e.preventDefault();
                        this.changeBet(1);
                    } else if (e.code === 'KeyM') {
                        e.preventDefault();
                        this.toggleMute();
                    }
                });
                
                // Initial render
                this.renderReels();
                this.updateUI();
                
                console.log('Initialization complete');
            }
            
            generateGrid() {
                // Get current visible symbols from reel positions (EXACTLY like simple-slot.html)
                this.grid = [];
                for (let reel = 0; reel < 3; reel++) {
                    for (let row = 0; row < 3; row++) {
                        const symbolIndex = Math.floor(this.reelPositions[reel] / 100 + row) % this.reels[reel].length;
                        this.grid[row * 3 + reel] = this.reels[reel][symbolIndex];
                    }
                }
                console.log('Grid from reel positions:', this.grid.map(s => s.name));
            }
            
            changeBet(delta) {
                if (this.spinning) return;
                this.bet = Math.max(1, Math.min(5, this.bet + delta));
                this.updateUI();
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                document.getElementById('mute-btn').textContent = this.isMuted ? 'MUTED' : 'SOUND';
            }
            
            spin() {
                if (this.spinning || this.credits < this.bet) {
                    console.log('Cannot spin - already spinning or insufficient credits');
                    return;
                }
                
                console.log('Starting spin...');
                this.spinning = true;
                this.credits -= this.bet;
                this.lastWin = 0;
                this.winningLines = [];
                this.updateUI();
                this.playSpinSound();
                
                // Start all reels spinning with HIGH-ENERGY EXCITEMENT! üöÄ
                for (let i = 0; i < 3; i++) {
                    this.reelSpinning[i] = true;
                    this.reelSpeeds[i] = 12 + Math.random() * 8; // High-energy speeds 12-20 for maximum excitement!
                }
                
                // Start animation
                this.startSpin();
                
                // Stop reels with MAXIMUM DRAMA - big gaps create suspense! üé≠
                setTimeout(() => this.stopReel(0), 1000);  // Left reel stops first
                setTimeout(() => this.stopReel(1), 2500);  // Middle reel stops after 1.5s gap!
                setTimeout(() => this.stopReel(2), 4000);  // Right reel stops after another 1.5s gap!
                
                // Check results after all reels stop (200ms after final reel)
                setTimeout(() => {
                    this.spinning = false;
                    this.generateGrid(); // Update grid from reel positions
                    this.checkWins();
                    this.updateUI();
                    console.log('All reels stopped - MAXIMUM DRAMA complete! üé≠');
                }, 4200);
            }
            
            stopReel(reelIndex) {
                console.log(`Stopping reel ${reelIndex}`);
                this.reelSpinning[reelIndex] = false;
                // Snap to nearest symbol position
                this.reelPositions[reelIndex] = Math.round(this.reelPositions[reelIndex] / 100) * 100;
            }
            
            startSpin() {
                console.log('Animation started');
                this.animate();
            }
            
            animate() {
                if (this.spinning || this.winningLines.length > 0) {
                    // Update spinning reels (EXACTLY like simple-slot.html)
                    for (let i = 0; i < 3; i++) {
                        if (this.reelSpinning[i]) {
                            this.reelPositions[i] += this.reelSpeeds[i];
                            // Wrap around when we reach the end of the reel
                            if (this.reelPositions[i] >= this.reels[i].length * 100) {
                                this.reelPositions[i] = 0;
                            }
                        }
                    }
                    
                    this.renderReels();
                    
                    // Continue animation
                    requestAnimationFrame(() => this.animate());
                } else {
                    // Show final result
                    this.renderReels();
                }
            }
            
            checkWins() {
                this.winningLines = [];
                let totalPayout = 0;
                
                this.paylines.forEach((payline) => {
                    const [pos1, pos2, pos3] = payline.indices;
                    const symbols = [this.grid[pos1], this.grid[pos2], this.grid[pos3]];
                    
                    if (symbols[0].name === symbols[1].name && symbols[1].name === symbols[2].name) {
                        const payout = symbols[0].payout * this.bet;
                        totalPayout += payout;
                        
                        this.winningLines.push({
                            payline: payline,
                            symbol: symbols[0],
                            payout: payout,
                            indices: payline.indices
                        });
                    }
                });
                
                if (totalPayout > 0) {
                    this.lastWin = totalPayout;
                    this.credits += totalPayout;
                    
                    const message = this.winningLines.length === 1 
                        ? `${this.winningLines[0].payline.name}: 3√ó${this.winningLines[0].symbol.name} ‚Üí +${totalPayout}`
                        : `${this.winningLines.length} LINES WON ‚Üí +${totalPayout}`;
                    
                    document.getElementById('win-message').textContent = message;
                    this.playWinSound();
                    this.showWinAnimation();
                    console.log('WIN!', message);
                } else {
                    document.getElementById('win-message').textContent = '';
                    console.log('No win');
                }
            }
            
            showWinAnimation() {
                let frame = 0;
                const animate = () => {
                    this.renderReels();
                    frame++;
                    if (frame < 120) { // 2 seconds at 60fps
                        requestAnimationFrame(animate);
                    } else {
                        this.winningLines = [];
                        this.renderReels();
                    }
                };
                animate();
            }
            
            renderReels() {
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, 300, 300);
                
                // Draw grid lines
                this.ctx.strokeStyle = '#00ff00';
                this.ctx.lineWidth = 2;
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 3; col++) {
                        this.ctx.strokeRect(col * 100, row * 100, 100, 100);
                    }
                }
                
                // Draw each reel (EXACTLY like simple-slot.html)
                for (let reelIndex = 0; reelIndex < 3; reelIndex++) {
                    this.drawReel(reelIndex);
                }
                
                // Draw winning lines
                if (this.winningLines.length > 0) {
                    this.drawWinningLines();
                }
            }
            
            drawReel(reelIndex) {
                const x = reelIndex * 100;
                
                // Save context for clipping
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.rect(x, 0, 100, 300);
                this.ctx.clip();
                
                // Set font
                this.ctx.font = '60px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillStyle = '#fff';
                
                // Add blur if spinning
                if (this.reelSpinning[reelIndex]) {
                    this.ctx.globalAlpha = 0.8;
                    this.ctx.filter = 'blur(1px)';
                }
                
                // Draw visible symbols (and a few above/below for smooth scrolling)
                const position = this.reelPositions[reelIndex];
                const startSymbol = Math.floor(position / 100) - 1;
                
                for (let i = 0; i < 6; i++) { // Draw 6 symbols to cover the visible area plus buffer
                    const symbolIndex = (startSymbol + i) % this.reels[reelIndex].length;
                    if (symbolIndex < 0) continue;
                    
                    const symbol = this.reels[reelIndex][symbolIndex];
                    const symbolX = x + 50;
                    const symbolY = (startSymbol + i) * 100 + 50 - position;
                    
                    this.ctx.fillStyle = symbol.color;
                    this.ctx.fillText(symbol.char, symbolX, symbolY);
                }
                
                // Reset effects
                this.ctx.globalAlpha = 1;
                this.ctx.filter = 'none';
                this.ctx.restore();
            }
            
            drawWinningLines() {
                const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                this.ctx.globalAlpha = pulse;
                this.ctx.strokeStyle = '#ffff00';
                this.ctx.lineWidth = 4;
                
                this.winningLines.forEach(win => {
                    this.ctx.beginPath();
                    win.indices.forEach((index, i) => {
                        const row = Math.floor(index / 3);
                        const col = index % 3;
                        const x = col * 100 + 50;
                        const y = row * 100 + 50;
                        
                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    });
                    this.ctx.stroke();
                    
                    // Highlight cells
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.globalAlpha = pulse * 0.2;
                    win.indices.forEach(index => {
                        const row = Math.floor(index / 3);
                        const col = index % 3;
                        const x = col * 100;
                        const y = row * 100;
                        this.ctx.fillRect(x + 2, y + 2, 98, 98);
                    });
                });
                
                this.ctx.globalAlpha = 1;
            }
            
            updateUI() {
                document.getElementById('credits').textContent = this.credits;
                document.getElementById('bet').textContent = this.bet;
                document.getElementById('last-win').textContent = this.lastWin;
                
                const spinBtn = document.getElementById('spin-btn');
                const canSpin = !this.spinning && this.credits >= this.bet;
                spinBtn.disabled = !canSpin;
                spinBtn.textContent = this.spinning ? 'SPINNING...' : 'SPIN     ';
                
                const betEnabled = !this.spinning;
                document.getElementById('bet-down').disabled = !betEnabled;
                document.getElementById('bet-up').disabled = !betEnabled;
            }
            
            playSpinSound() {
                if (this.isMuted || !this.audioContext) return;
                
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(80, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(60, this.audioContext.currentTime + 1.5);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.1, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 1.5);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 1.5);
                } catch (e) {
                    console.warn('Audio generation failed:', e);
                }
            }
            
            playWinSound() {
                if (this.isMuted || !this.audioContext) return;
                
                try {
                    const oscillator1 = this.audioContext.createOscillator();
                    const oscillator2 = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator1.connect(gainNode);
                    oscillator2.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator1.type = 'sine';
                    oscillator2.type = 'triangle';
                    
                    oscillator1.frequency.setValueAtTime(523, this.audioContext.currentTime);
                    oscillator1.frequency.setValueAtTime(659, this.audioContext.currentTime + 0.2);
                    oscillator1.frequency.setValueAtTime(784, this.audioContext.currentTime + 0.4);
                    
                    oscillator2.frequency.setValueAtTime(262, this.audioContext.currentTime);
                    oscillator2.frequency.setValueAtTime(330, this.audioContext.currentTime + 0.2);
                    oscillator2.frequency.setValueAtTime(392, this.audioContext.currentTime + 0.4);
                    
                    gainNode.gain.setValueAtTime(0, this.audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.15, this.audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.8);
                    
                    oscillator1.start(this.audioContext.currentTime);
                    oscillator2.start(this.audioContext.currentTime);
                    oscillator1.stop(this.audioContext.currentTime + 0.8);
                    oscillator2.stop(this.audioContext.currentTime + 0.8);
                } catch (e) {
                    console.warn('Win sound generation failed:', e);
                }
            }
        }
        
        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, creating game...');
            const game = new RetroSlotMachine();
            window.game = game; // For debugging
        });
    </script>
</body>
</html>