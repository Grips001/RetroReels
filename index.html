<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro 3-Reel Slot Machine</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --container-bg: #2a2a2a;
            --primary-color: #00ff00;
            --secondary-color: #004400;
            --accent-color: #ffff00;
            --canvas-bg: #000000;
            --grid-color: #00ff00;
        }
        
        body {
            margin: 0;
            padding: 20px;
            background: var(--bg-color);
            color: var(--primary-color);
            font-family: "Courier New", monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            transition: all 0.3s ease;
        }
        
        #game-container {
            text-align: center;
            background: var(--container-bg);
            padding: 20px;
            border: 2px solid var(--primary-color);
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        canvas {
            border: 1px solid var(--primary-color);
            background: var(--canvas-bg);
            transition: all 0.3s ease;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }
        
        button {
            background: var(--secondary-color);
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
            padding: 10px 20px;
            font-family: inherit;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: var(--primary-color);
            color: var(--secondary-color);
        }
        
        button:focus {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #spin-btn {
            min-width: 120px;
        }
        
        .status {
            margin-top: 15px;
            font-size: 14px;
        }
        
        .win-message {
            margin-top: 10px;
            color: var(--accent-color);
            font-weight: bold;
            min-height: 20px;
            transition: all 0.3s ease;
        }
        
        .paytable {
            margin-top: 20px;
            font-size: 12px;
            text-align: left;
            max-width: 300px;
        }
        
        .paytable h3 {
            color: var(--accent-color);
            margin-bottom: 10px;
            transition: all 0.3s ease;
        }
        
        .controls-help {
            margin-top: 20px;
            font-size: 13px;
            text-align: left;
            max-width: 350px;
            opacity: 0.8;
        }
        
        .controls-help h3 {
            color: var(--accent-color);
            margin-bottom: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .control-section {
            margin-bottom: 6px;
        }
        
        .control-title {
            color: var(--primary-color);
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 2px;
            transition: all 0.3s ease;
        }
        
        .control-section div:last-child {
            color: var(--primary-color);
            opacity: 0.7;
            font-size: 12px;
            line-height: 1.3;
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>RETRO SLOT</h1>
        <canvas id="game-canvas" width="300" height="300"></canvas>
        
        <div class="controls">
            <button id="bet-down" aria-label="Decrease bet">BET -</button>
            <button id="spin-btn" aria-label="Spin reels">SPIN</button>
            <button id="bet-up" aria-label="Increase bet">BET +</button>
            <button id="theme-btn" aria-label="Change theme">THEME</button>
            <button id="mute-btn" aria-label="Toggle sound">SOUND</button>
        </div>
        
        <div class="status">
            <div>Credits: <span id="credits">100</span></div>
            <div>Bet: <span id="bet">1</span></div>
            <div>Last Win: <span id="last-win">0</span></div>
        </div>
        
        <div class="win-message" id="win-message" aria-live="polite"></div>
        
        <div class="paytable">
            <h3>PAYTABLE (BET: <span id="paytable-bet">1</span>)</h3>
            <div>3√ó SEVEN: <span id="payout-seven">50</span> credits</div>
            <div>3√ó BELL: <span id="payout-bell">40</span> credits</div>
            <div>3√ó STAR: <span id="payout-star">30</span> credits</div>
            <div>3√ó DIAMOND: <span id="payout-diamond">20</span> credits</div>
            <div>3√ó CHERRY: <span id="payout-cherry">10</span> credits</div>
            <div>3√ó LEMON: <span id="payout-lemon">5</span> credits</div>
        </div>
        
        <div class="controls-help">
            <h3>CONTROLS</h3>
            <div class="control-section">
                <div class="control-title">üñ±Ô∏è MOUSE</div>
                <div>Click buttons to play</div>
            </div>
            <div class="control-section">
                <div class="control-title">‚å®Ô∏è KEYBOARD</div>
                <div>SPACE = Spin ‚Ä¢ ‚Üê‚Üí = Bet ‚Ä¢ T = Theme ‚Ä¢ M = Mute</div>
            </div>
        </div>
    </div>

    <script>
        class RetroSlotMachine {
            constructor() {
                // Symbols with payouts (based on working simple-slot.html structure)
                this.symbols = [
                    { char: 'üçí', name: 'CHERRY', payout: 10, color: '#ff4444' },
                    { char: 'üçã', name: 'LEMON', payout: 5, color: '#ffff44' },
                    { char: 'üíé', name: 'DIAMOND', payout: 20, color: '#00ccff' },
                    { char: 'üîî', name: 'BELL', payout: 40, color: '#ffaa00' },
                    { char: '‚òÖ', name: 'STAR', payout: 30, color: '#4444ff' },
                    { char: '7', name: 'SEVEN', payout: 50, color: '#44ff44' }
                ];
                
                // 9 paylines for 3x3 grid
                this.paylines = [
                    { name: 'Top Row', indices: [0, 1, 2] },
                    { name: 'Middle Row', indices: [3, 4, 5] },
                    { name: 'Bottom Row', indices: [6, 7, 8] },
                    { name: 'Main Diagonal', indices: [0, 4, 8] },
                    { name: 'Anti Diagonal', indices: [2, 4, 6] },
                    { name: 'Left Column', indices: [0, 3, 6] },
                    { name: 'Middle Column', indices: [1, 4, 7] },
                    { name: 'Right Column', indices: [2, 5, 8] },
                    { name: 'V-Shape', indices: [0, 4, 2] }
                ];
                
                // Create 3 physical reels with fixed symbol sequences (EXACTLY like simple-slot.html)
                this.reels = [
                    this.createReel(), // Left reel
                    this.createReel(), // Middle reel  
                    this.createReel()  // Right reel
                ];
                
                // Reel positions (how far down each reel has scrolled)
                this.reelPositions = [0, 0, 0];
                this.reelSpeeds = [0, 0, 0];
                this.reelSpinning = [false, false, false];
                
                // Game state
                this.credits = 100;
                this.bet = 1;
                this.lastWin = 0;
                this.spinning = false;
                this.isMuted = false;
                this.winningLines = [];
                
                // Theme system
                this.currentTheme = 0;
                this.themes = this.createThemes();
                
                // Canvas
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Audio
                this.audioContext = null;
                this.initAudio();
                
                this.init();
            }
            
            createReel() {
                // Create a reel with 20 symbols in a fixed sequence (EXACTLY like simple-slot.html)
                const reel = [];
                for (let i = 0; i < 20; i++) {
                    reel.push(this.symbols[Math.floor(Math.random() * this.symbols.length)]);
                }
                return reel;
            }
            
            createThemes() {
                return [
                    {
                        name: 'RETRO GREEN',
                        background: '#1a1a1a',
                        containerBg: '#2a2a2a',
                        primary: '#00ff00',
                        secondary: '#004400',
                        accent: '#ffff00',
                        canvasBg: '#000000',
                        gridColor: '#00ff00'
                    },
                    {
                        name: 'NEON PINK',
                        background: '#1a0a1a',
                        containerBg: '#2a1a2a',
                        primary: '#ff00ff',
                        secondary: '#440044',
                        accent: '#00ffff',
                        canvasBg: '#000000',
                        gridColor: '#ff00ff'
                    },
                    {
                        name: 'CYBER BLUE',
                        background: '#0a0a1a',
                        containerBg: '#1a1a2a',
                        primary: '#00aaff',
                        secondary: '#002244',
                        accent: '#ffaa00',
                        canvasBg: '#000011',
                        gridColor: '#00aaff'
                    },
                    {
                        name: 'GOLD RUSH',
                        background: '#1a1a0a',
                        containerBg: '#2a2a1a',
                        primary: '#ffaa00',
                        secondary: '#442200',
                        accent: '#ffffff',
                        canvasBg: '#110800',
                        gridColor: '#ffaa00'
                    },
                    {
                        name: 'FIRE RED',
                        background: '#1a0a0a',
                        containerBg: '#2a1a1a',
                        primary: '#ff4400',
                        secondary: '#440000',
                        accent: '#ffff00',
                        canvasBg: '#110000',
                        gridColor: '#ff4400'
                    }
                ];
            }
            
            initAudio() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                }
            }
            
            enableAudio() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    this.audioContext.resume().catch(e => console.warn('Audio resume failed:', e));
                }
            }
            
            init() {
                console.log('Initializing retro slot machine...');
                console.log('Reels created:', this.reels.map(reel => reel.slice(0, 5).map(s => s.char))); // Show first 5 symbols of each reel
                
                // Generate initial grid
                this.generateGrid();
                
                // Setup buttons
                document.getElementById('spin-btn').addEventListener('click', () => {
                    console.log('Spin button clicked');
                    this.enableAudio();
                    this.spin();
                });
                
                document.getElementById('bet-down').addEventListener('click', () => {
                    this.enableAudio();
                    this.changeBet(-1);
                });
                
                document.getElementById('bet-up').addEventListener('click', () => {
                    this.enableAudio();
                    this.changeBet(1);
                });
                
                document.getElementById('mute-btn').addEventListener('click', () => this.toggleMute());
                
                document.getElementById('theme-btn').addEventListener('click', () => {
                    this.enableAudio();
                    this.cycleTheme();
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.enableAudio();
                        this.spin();
                    } else if (e.code === 'ArrowLeft') {
                        e.preventDefault();
                        this.changeBet(-1);
                    } else if (e.code === 'ArrowRight') {
                        e.preventDefault();
                        this.changeBet(1);
                    } else if (e.code === 'KeyM') {
                        e.preventDefault();
                        this.toggleMute();
                    } else if (e.code === 'KeyT') {
                        e.preventDefault();
                        this.cycleTheme();
                    }
                });
                
                // Initialize theme
                this.applyTheme();
                
                // Initial render
                this.renderReels();
                this.updateUI();
                
                console.log('Initialization complete');
            }
            
            generateGrid() {
                // Get current visible symbols from reel positions (EXACTLY like simple-slot.html)
                this.grid = [];
                for (let reel = 0; reel < 3; reel++) {
                    for (let row = 0; row < 3; row++) {
                        const symbolIndex = Math.floor(this.reelPositions[reel] / 100 + row) % this.reels[reel].length;
                        this.grid[row * 3 + reel] = this.reels[reel][symbolIndex];
                    }
                }
                console.log('Grid from reel positions:', this.grid.map(s => s.name));
            }
            
            changeBet(delta) {
                if (this.spinning) return;
                this.bet = Math.max(1, Math.min(5, this.bet + delta));
                this.updateUI();
            }
            
            toggleMute() {
                this.isMuted = !this.isMuted;
                document.getElementById('mute-btn').textContent = this.isMuted ? 'MUTED' : 'SOUND';
            }
            
            cycleTheme() {
                if (this.spinning) return; // Don't change theme while spinning
                
                this.currentTheme = (this.currentTheme + 1) % this.themes.length;
                this.applyTheme();
                console.log(`Theme changed to: ${this.themes[this.currentTheme].name}`);
            }
            
            applyTheme() {
                const theme = this.themes[this.currentTheme];
                const root = document.documentElement;
                
                // Apply CSS custom properties
                root.style.setProperty('--bg-color', theme.background);
                root.style.setProperty('--container-bg', theme.containerBg);
                root.style.setProperty('--primary-color', theme.primary);
                root.style.setProperty('--secondary-color', theme.secondary);
                root.style.setProperty('--accent-color', theme.accent);
                root.style.setProperty('--canvas-bg', theme.canvasBg);
                root.style.setProperty('--grid-color', theme.gridColor);
                
                // Update theme button text
                document.getElementById('theme-btn').textContent = theme.name;
                
                // Re-render with new colors
                this.renderReels();
            }
            
            spin() {
                if (this.spinning || this.credits < this.bet) {
                    console.log('Cannot spin - already spinning or insufficient credits');
                    return;
                }
                
                console.log('Starting spin...');
                this.spinning = true;
                this.credits -= this.bet;
                this.lastWin = 0;
                this.winningLines = [];
                this.updateUI();
                this.playSpinSound();
                
                // Start all reels spinning with HIGH-ENERGY EXCITEMENT! üöÄ
                for (let i = 0; i < 3; i++) {
                    this.reelSpinning[i] = true;
                    this.reelSpeeds[i] = 12 + Math.random() * 8; // High-energy speeds 12-20 for maximum excitement!
                }
                
                // Start animation
                this.startSpin();
                
                // Stop reels with MAXIMUM DRAMA - big gaps create suspense! üé≠
                setTimeout(() => this.stopReel(0), 1000);  // Left reel stops first
                setTimeout(() => this.stopReel(1), 2500);  // Middle reel stops after 1.5s gap!
                setTimeout(() => this.stopReel(2), 4000);  // Right reel stops after another 1.5s gap!
                
                // Check results after all reels stop (200ms after final reel)
                setTimeout(() => {
                    this.spinning = false;
                    this.generateGrid(); // Update grid from reel positions
                    this.checkWins();
                    this.updateUI();
                    console.log('All reels stopped - MAXIMUM DRAMA complete! üé≠');
                }, 4200);
            }
            
            stopReel(reelIndex) {
                console.log(`Stopping reel ${reelIndex}`);
                this.reelSpinning[reelIndex] = false;
                // Snap to nearest symbol position
                this.reelPositions[reelIndex] = Math.round(this.reelPositions[reelIndex] / 100) * 100;
            }
            
            startSpin() {
                console.log('Animation started');
                this.animate();
            }
            
            animate() {
                if (this.spinning || this.winningLines.length > 0) {
                    // Update spinning reels (EXACTLY like simple-slot.html)
                    for (let i = 0; i < 3; i++) {
                        if (this.reelSpinning[i]) {
                            this.reelPositions[i] += this.reelSpeeds[i];
                            // Wrap around when we reach the end of the reel
                            if (this.reelPositions[i] >= this.reels[i].length * 100) {
                                this.reelPositions[i] = 0;
                            }
                        }
                    }
                    
                    this.renderReels();
                    
                    // Continue animation
                    requestAnimationFrame(() => this.animate());
                } else {
                    // Show final result
                    this.renderReels();
                }
            }
            
            checkWins() {
                this.winningLines = [];
                let totalPayout = 0;
                
                this.paylines.forEach((payline) => {
                    const [pos1, pos2, pos3] = payline.indices;
                    const symbols = [this.grid[pos1], this.grid[pos2], this.grid[pos3]];
                    
                    if (symbols[0].name === symbols[1].name && symbols[1].name === symbols[2].name) {
                        const payout = symbols[0].payout * this.bet;
                        totalPayout += payout;
                        
                        this.winningLines.push({
                            payline: payline,
                            symbol: symbols[0],
                            payout: payout,
                            indices: payline.indices
                        });
                    }
                });
                
                if (totalPayout > 0) {
                    this.lastWin = totalPayout;
                    this.credits += totalPayout;
                    
                    const message = this.winningLines.length === 1 
                        ? `${this.winningLines[0].payline.name}: 3√ó${this.winningLines[0].symbol.name} ‚Üí +${totalPayout}`
                        : `${this.winningLines.length} LINES WON ‚Üí +${totalPayout}`;
                    
                    document.getElementById('win-message').textContent = message;
                    this.playWinSound();
                    this.showWinAnimation();
                    console.log('WIN!', message);
                } else {
                    document.getElementById('win-message').textContent = '';
                    console.log('No win');
                }
            }
            
            showWinAnimation() {
                let frame = 0;
                const animate = () => {
                    this.renderReels();
                    frame++;
                    if (frame < 120) { // 2 seconds at 60fps
                        requestAnimationFrame(animate);
                    } else {
                        this.winningLines = [];
                        this.renderReels();
                    }
                };
                animate();
            }
            
            renderReels() {
                const theme = this.themes[this.currentTheme];
                
                // Clear canvas with theme background
                this.ctx.fillStyle = theme.canvasBg;
                this.ctx.fillRect(0, 0, 300, 300);
                
                // Draw grid lines with theme color
                this.ctx.strokeStyle = theme.gridColor;
                this.ctx.lineWidth = 2;
                for (let row = 0; row < 3; row++) {
                    for (let col = 0; col < 3; col++) {
                        this.ctx.strokeRect(col * 100, row * 100, 100, 100);
                    }
                }
                
                // Draw each reel (EXACTLY like simple-slot.html)
                for (let reelIndex = 0; reelIndex < 3; reelIndex++) {
                    this.drawReel(reelIndex);
                }
                
                // Draw winning lines
                if (this.winningLines.length > 0) {
                    this.drawWinningLines();
                }
            }
            
            drawReel(reelIndex) {
                const x = reelIndex * 100;
                
                // Save context for clipping
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.rect(x, 0, 100, 300);
                this.ctx.clip();
                
                // Set font
                this.ctx.font = '60px monospace';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillStyle = '#fff';
                
                // Add blur if spinning
                if (this.reelSpinning[reelIndex]) {
                    this.ctx.globalAlpha = 0.8;
                    this.ctx.filter = 'blur(1px)';
                }
                
                // Draw visible symbols (and a few above/below for smooth scrolling)
                const position = this.reelPositions[reelIndex];
                const startSymbol = Math.floor(position / 100) - 1;
                
                for (let i = 0; i < 6; i++) { // Draw 6 symbols to cover the visible area plus buffer
                    const symbolIndex = (startSymbol + i) % this.reels[reelIndex].length;
                    if (symbolIndex < 0) continue;
                    
                    const symbol = this.reels[reelIndex][symbolIndex];
                    const symbolX = x + 50;
                    const symbolY = (startSymbol + i) * 100 + 50 - position;
                    
                    this.ctx.fillStyle = symbol.color;
                    this.ctx.fillText(symbol.char, symbolX, symbolY);
                }
                
                // Reset effects
                this.ctx.globalAlpha = 1;
                this.ctx.filter = 'none';
                this.ctx.restore();
            }
            
            drawWinningLines() {
                const theme = this.themes[this.currentTheme];
                const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                this.ctx.globalAlpha = pulse;
                this.ctx.strokeStyle = theme.accent;
                this.ctx.lineWidth = 4;
                
                this.winningLines.forEach(win => {
                    this.ctx.beginPath();
                    win.indices.forEach((index, i) => {
                        const row = Math.floor(index / 3);
                        const col = index % 3;
                        const x = col * 100 + 50;
                        const y = row * 100 + 50;
                        
                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    });
                    this.ctx.stroke();
                    
                    // Highlight cells
                    this.ctx.fillStyle = theme.accent;
                    this.ctx.globalAlpha = pulse * 0.2;
                    win.indices.forEach(index => {
                        const row = Math.floor(index / 3);
                        const col = index % 3;
                        const x = col * 100;
                        const y = row * 100;
                        this.ctx.fillRect(x + 2, y + 2, 98, 98);
                    });
                });
                
                this.ctx.globalAlpha = 1;
            }
            
            updateUI() {
                document.getElementById('credits').textContent = this.credits;
                document.getElementById('bet').textContent = this.bet;
                document.getElementById('last-win').textContent = this.lastWin;
                
                const spinBtn = document.getElementById('spin-btn');
                const canSpin = !this.spinning && this.credits >= this.bet;
                spinBtn.disabled = !canSpin;
                spinBtn.textContent = this.spinning ? 'SPINNING...' : 'SPIN     ';
                
                const betEnabled = !this.spinning;
                document.getElementById('bet-down').disabled = !betEnabled;
                document.getElementById('bet-up').disabled = !betEnabled;
                
                // Update paytable with current bet multiplier
                this.updatePaytable();
            }
            
            updatePaytable() {
                document.getElementById('paytable-bet').textContent = this.bet;
                
                // Update each payout value based on current bet
                this.symbols.forEach(symbol => {
                    const elementId = `payout-${symbol.name.toLowerCase()}`;
                    const element = document.getElementById(elementId);
                    if (element) {
                        element.textContent = symbol.payout * this.bet;
                    }
                });
            }
            
            playSpinSound() {
                if (this.isMuted || !this.audioContext) return;
                
                try {
                    // Create that classic casino jingle - "glittery musical confetti"!
                    const duration = 4.2;
                    const startTime = this.audioContext.currentTime;
                    
                    // Base frequencies for our ascending cascade
                    const baseFreqs = [523, 659, 784, 880, 1047, 1319]; // C5, E5, G5, A5, C6, E6
                    const noteInterval = 0.08; // Fast staccato notes
                    const totalNotes = Math.floor(duration / noteInterval);
                    
                    // Create the sparkling cascade of digital bells
                    for (let i = 0; i < totalNotes; i++) {
                        const noteTime = startTime + (i * noteInterval);
                        const progress = i / totalNotes;
                        
                        // Create each "bell chime"
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        const filter = this.audioContext.createBiquadFilter();
                        
                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(this.audioContext.destination);
                        
                        // Bright, crystalline tone
                        osc.type = 'sine';
                        
                        // Ascending pattern with some randomness for sparkle
                        const freqIndex = Math.floor(progress * baseFreqs.length) % baseFreqs.length;
                        const baseFreq = baseFreqs[freqIndex];
                        const sparkle = 1 + (Math.random() * 0.1 - 0.05); // ¬±5% sparkle
                        osc.frequency.setValueAtTime(baseFreq * sparkle, noteTime);
                        
                        // High-pass filter for crystalline brightness
                        filter.type = 'highpass';
                        filter.frequency.setValueAtTime(400, noteTime);
                        filter.Q.setValueAtTime(2, noteTime);
                        
                        // Quick attack, short decay for staccato effect
                        const noteLength = noteInterval * 0.6;
                        const volume = 0.08 + (progress * 0.1); // Builds in intensity - LOUDER!
                        
                        gain.gain.setValueAtTime(0, noteTime);
                        gain.gain.linearRampToValueAtTime(volume, noteTime + 0.005);
                        gain.gain.exponentialRampToValueAtTime(0.001, noteTime + noteLength);
                        
                        osc.start(noteTime);
                        osc.stop(noteTime + noteLength);
                    }
                    
                    // Add harmonic shimmer layer
                    const shimmerOsc = this.audioContext.createOscillator();
                    const shimmerGain = this.audioContext.createGain();
                    const shimmerFilter = this.audioContext.createBiquadFilter();
                    
                    shimmerOsc.connect(shimmerFilter);
                    shimmerFilter.connect(shimmerGain);
                    shimmerGain.connect(this.audioContext.destination);
                    
                    shimmerOsc.type = 'triangle';
                    shimmerOsc.frequency.setValueAtTime(1047, startTime); // High C
                    shimmerOsc.frequency.exponentialRampToValueAtTime(2093, startTime + duration); // Octave climb
                    
                    shimmerFilter.type = 'bandpass';
                    shimmerFilter.frequency.setValueAtTime(2000, startTime);
                    shimmerFilter.Q.setValueAtTime(3, startTime);
                    
                    shimmerGain.gain.setValueAtTime(0, startTime);
                    shimmerGain.gain.linearRampToValueAtTime(0.04, startTime + 0.5);
                    shimmerGain.gain.linearRampToValueAtTime(0.06, startTime + duration - 0.5);
                    shimmerGain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
                    
                    shimmerOsc.start(startTime);
                    shimmerOsc.stop(startTime + duration);
                    
                } catch (e) {
                    console.warn('Audio generation failed:', e);
                }
            }
            
            playWinSound() {
                if (this.isMuted || !this.audioContext) return;
                
                try {
                    // Create a triumphant win celebration - cascading victory bells! üéâ
                    const duration = 2.0;
                    const startTime = this.audioContext.currentTime;
                    
                    // PHASE 1: Triumphant fanfare chord (0.0-0.5s)
                    const fanfareChord = [1047, 1319, 1568, 2093]; // C6, E6, G6, C7 - bright and triumphant!
                    fanfareChord.forEach((freq, index) => {
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        const filter = this.audioContext.createBiquadFilter();
                        
                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(this.audioContext.destination);
                        
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(freq, startTime);
                        
                        filter.type = 'highpass';
                        filter.frequency.setValueAtTime(400, startTime);
                        filter.Q.setValueAtTime(2, startTime);
                        
                        gain.gain.setValueAtTime(0, startTime);
                        gain.gain.linearRampToValueAtTime(0.12, startTime + 0.02);
                        gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);
                        
                        osc.start(startTime);
                        osc.stop(startTime + 0.5);
                    });
                    
                    // PHASE 2: Cascading victory bells (0.3-1.8s) - like coins falling!
                    const cascadeFreqs = [2093, 2349, 2637, 2794, 3136, 3520, 3951]; // High sparkling notes
                    const cascadeCount = 20;
                    
                    for (let i = 0; i < cascadeCount; i++) {
                        const noteTime = startTime + 0.3 + (i * 0.07); // Rapid cascade
                        const freq = cascadeFreqs[i % cascadeFreqs.length];
                        const sparkle = 1 + (Math.random() * 0.08 - 0.04); // Sparkle variation
                        
                        const osc = this.audioContext.createOscillator();
                        const gain = this.audioContext.createGain();
                        const filter = this.audioContext.createBiquadFilter();
                        
                        osc.connect(filter);
                        filter.connect(gain);
                        gain.connect(this.audioContext.destination);
                        
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(freq * sparkle, noteTime);
                        
                        // Ultra-bright crystalline filter
                        filter.type = 'highpass';
                        filter.frequency.setValueAtTime(1000, noteTime);
                        filter.Q.setValueAtTime(3, noteTime);
                        
                        // Quick sparkly attack
                        const volume = 0.05 + (Math.random() * 0.02); // Slight volume variation
                        gain.gain.setValueAtTime(0, noteTime);
                        gain.gain.linearRampToValueAtTime(volume, noteTime + 0.003);
                        gain.gain.exponentialRampToValueAtTime(0.001, noteTime + 0.12);
                        
                        osc.start(noteTime);
                        osc.stop(noteTime + 0.12);
                    }
                    
                    // PHASE 3: Final triumphant sustain (1.5-2.0s)
                    const finalOsc = this.audioContext.createOscillator();
                    const finalGain = this.audioContext.createGain();
                    const finalFilter = this.audioContext.createBiquadFilter();
                    
                    finalOsc.connect(finalFilter);
                    finalFilter.connect(finalGain);
                    finalGain.connect(this.audioContext.destination);
                    
                    finalOsc.type = 'triangle';
                    finalOsc.frequency.setValueAtTime(1047, startTime + 1.5); // Resolves to C6
                    
                    finalFilter.type = 'lowpass';
                    finalFilter.frequency.setValueAtTime(2000, startTime + 1.5);
                    finalFilter.Q.setValueAtTime(1, startTime + 1.5);
                    
                    finalGain.gain.setValueAtTime(0, startTime + 1.5);
                    finalGain.gain.linearRampToValueAtTime(0.08, startTime + 1.55);
                    finalGain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
                    
                    finalOsc.start(startTime + 1.5);
                    finalOsc.stop(startTime + duration);
                    
                } catch (e) {
                    console.warn('Win sound generation failed:', e);
                }
            }
        }
        
        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, creating game...');
            const game = new RetroSlotMachine();
            window.game = game; // For debugging
        });
    </script>
</body>
</html>